# さて、次はイテレータについて見ていきましょう。
# イテレータはざっくり言うと、次の要素を返してくれるデータの集合になります。
# 例を見ていきましょう。
# ではリストを作っていきます。
# scores = [40, 50, 70, 90, 60] としてあげましょう。
# ここで、次の要素を引っ張ってくる関数を作るのはわりと面倒だったりするのですが、リストをイテレータに変換すれば簡単に実現することができます。
# 変換するには iter() という命令を使ってあげてください。
# it = iter(scores) でリストがイテレータになったので、next() という命令で次の要素をいつでも引っ張ってくることができます。
# ではこちらで print(next(it)) としてあげると、40 が表示されるはずです。
# 次にまた実行してあげると 50 が表示されるはずです。
# それから途中で別の処理を挟んでも、ちゃんとどこまで要素を取得したかを覚えていてくれます。
# 例えば、ここで print("hello") としてあげて、その後にまた同じ命令を呼んであげると今度は 70 が表示されるはずです。
# ではうまくいったかどうか、こちらの方で確かめてみましょう…こうですね、想定通りになっているのがわかるかと思います。
# ちなみに、今まで見てきた次のような for 文ではこのように for score in scores: print(score) としてきましたが、実は for 文では、ここにくる変数にイテレータを期待していて、ここにリストを書くと自動的にイテレータに変換してくれます。
# そして内部的に next() を呼ぶことで print(score) の処理を実現していることも知っておくといいでしょう。
# それから、リストから変換するのではなくて 0 からイテレータを作ることもできます。
# ではせっかくなので、リストでは実現できない無限の要素を持つイテレータを作ってみましょう。
# ではまず関数を作ってあげます。
# def get_infinite(): としてあげて、 i = 0 で初期化しつつ、無限ループを while True: で書いてあげて、その中で次の要素を引っ張ってくる yield i * 2 という命令を使ってあげて、では今回 i を 2 倍したものを引っ張ってきてあげましょう。
# その後に i += 1 で i を 1 ずつ増やしていってあげます。
# ちなみに、イテレータを作るこうした関数をジェネレータと呼ぶので、用語として覚えておきましょう。
# ではこのジェネレータを使ってみます。
# では g = get_infinite() としてあげましょう。
# print(next(g)) とすると、まず最初の要素が取り出されて無限に next() を呼ぶことができるのですが 2 回くらいやってみましょう。
# では実行してあげると…こうですね、想定通りになっています。
# それからジェネレータでは、next() を呼ばれた時に初めて次の要素を探しにいく仕様になっているので、今回のように無限の要素を扱うことができるようになっていることも知っておきましょう。
# イテレータは奥が深いのですが、まずはこのあたりを押さえておいてください。


# イテレータ

scores = [40, 50, 70, 90, 60]
it = iter(scores)
print(next(it))
print(next(it))
print("hello")
print(next(it))

