# さて、次は例外処理について見ていきましょう。
# これはプログラムの実行中に予期せぬ結果が発生した時、適切に処理していく方法なのですが…、例を見ていきましょう。
# 今、割り算のメソッドがあって、ここでわざと 0 除算をしてみましょう。
# そうすると、このようなエラーが出てくるのですが、この時にわかりやすいメッセージを出したり別の処理をしたい場合に例外の仕組みが使えます。
# どうするかというと、例外の発生しそうなところをとりあえず try: で囲ってあげて except で例外を補足してあげます。
# 今回 ZeroDivisionError が出ているのでこちらで補足してあげて、その場合の処理は好きに書いていくことができるのですが、今回は「not by zero!」というメッセージを表示するだけにしてあげましょう。
# それから、例外が発生しなかった時の処理は else: につなげて書くことができます。
# では、今回 print("no exception!") としてあげましょう。
# それから例外が発生しようがしまいが、最後に処理を行いたい場合は finally: の後に書いてあげれば OK です。
# では今回適当に print("-- end --") としてあげましょう。
# では、今回例外が発生しない場合も見てみたいので、こちらに命令を付け足しておきましょう。
# ではこのようにしてあげると…、こうですね、うまくいっているのがわかるかと思います。
# それから ZeroDivisionError は Python があらかじめ用意してくれた例外なのですが、独自の例外を作りたい時もあります。
# そのやり方を見ておきましょう。
# どうするかというと、Python が用意している Exception クラスを継承して独自の例外を作ってあげれば OK です。
# いろいろな処理ができるのですが、とりあえず空のクラスにしておきましょう。
# では、この MyException クラスなのですが、今回何らかの理由で、もし b が 0 より小さかったら発生させたかったとしましょう。
# その場合は raise としてあげて…、raise MyException としてあげてください。
# メッセージをコンストラクタに渡すことができるのですが、今回は raise MyException("not minus") としてあげたいと思います。
# あとは、この MyException を補足すればいいので…、こちらで補足してあげて、変数で受けてあげてこの変数を表示すると、こちらのメッセージが表示される仕組みになっているので覚えておきましょう。
# ではうまくいくかどうかを見てみたいと思います。
# ではマイナスで除算をしてみたいと思います。
# こちらで見てあげると…、こうですね、想定通りになっているのがわかるかと思います。
# こういった例外の処理もよく使うので、慣れておくようにしてください。


# 例外処理
class MyException(Exception):
    pass

def div(a, b):
    try:
        if (b < 0):
            raise MyException("not minus")
        # bが 0未満の場合 エラーとする



        print(a / b)
    except ZeroDivisionError: #tryでエラーが出た場合の処理
        print("not by zero!")
    except MyException as e: #MyException で例外とした場合、raise MyException("not minus") の()内のメッセージをeとする
        print(e)
    else:
        print("no exception!")#tryでエラーが出なかった場合の追加処理
    finally:
        print("-- end --") #tryでエラーが出ようがでなかろうが行う処理

div(10, 3)
div(10, 0)

